/**
 * OpenCode Build Target
 *
 * Generates flat OpenCode structure:
 * dist/opencode/
 * ├── skill/
 * │   ├── python/
 * │   ├── typescript/
 * │   └── ...
 * ├── agent/
 * │   ├── pm.md
 * │   ├── backend-dev.md
 * │   └── ...
 * ├── command/
 * │   ├── start-session.md
 * │   └── ...
 * └── plugin/
 *     └── hooks.js
 */

import { mkdirSync, cpSync, writeFileSync, existsSync } from "fs";
import { join } from "path";

/**
 * Build OpenCode distribution
 */
export async function build({ config, rootDir, distDir }) {
  // Clean and create dist directory
  mkdirSync(distDir, { recursive: true });

  // Copy skills
  copySkills(rootDir, distDir);

  // Copy agents
  copyAgents(rootDir, distDir);

  // Copy commands
  copyCommands(rootDir, distDir);

  // Generate hooks.js
  generateHooks(config, rootDir, distDir);
}

/**
 * Copy all skills
 */
function copySkills(rootDir, distDir) {
  const src = join(rootDir, "skills");
  const dest = join(distDir, "skill");

  if (existsSync(src)) {
    cpSync(src, dest, { recursive: true });
  }
}

/**
 * Copy all agents
 */
function copyAgents(rootDir, distDir) {
  const src = join(rootDir, "agents");
  const dest = join(distDir, "agent");

  if (existsSync(src)) {
    cpSync(src, dest, { recursive: true });
  }
}

/**
 * Copy all commands
 */
function copyCommands(rootDir, distDir) {
  const src = join(rootDir, "commands");
  const dest = join(distDir, "command");

  if (existsSync(src)) {
    cpSync(src, dest, { recursive: true });
  }
}

/**
 * Generate OpenCode hooks.js
 *
 * OpenCode hook format:
 * - tool.execute.pre.<matcher>
 * - tool.execute.post.<matcher>
 * - session.start
 * - session.end
 */
function generateHooks(config, rootDir, distDir) {
  const pluginDir = join(distDir, "plugin");
  mkdirSync(pluginDir, { recursive: true });

  // Copy hooks lib and scripts
  const hooksSrc = join(rootDir, "hooks");
  const hooksDest = join(pluginDir, "hooks");
  if (existsSync(hooksSrc)) {
    cpSync(hooksSrc, hooksDest, { recursive: true });
  }

  // Generate hooks.js
  const hooksJs = generateHooksJs(config);
  writeFileSync(join(pluginDir, "hooks.js"), hooksJs);
}

/**
 * Generate hooks.js content
 */
function generateHooksJs(config) {
  const preToolHooks = config.hooks["pre-tool"] || [];
  const postToolHooks = config.hooks["post-tool"] || [];
  const sessionHooks = config.hooks.session || [];

  // Group pre-tool by matcher
  const preToolByMatcher = {};
  for (const hook of preToolHooks) {
    const matcher = hook.matcher || "Edit|Write";
    if (!preToolByMatcher[matcher]) {
      preToolByMatcher[matcher] = [];
    }
    preToolByMatcher[matcher].push(hook);
  }

  // Group post-tool by matcher
  const postToolByMatcher = {};
  for (const hook of postToolHooks) {
    const matcher = hook.matcher || "Edit|Write";
    if (!postToolByMatcher[matcher]) {
      postToolByMatcher[matcher] = [];
    }
    postToolByMatcher[matcher].push(hook);
  }

  return `/**
 * OpenCode Hooks Configuration
 * Auto-generated by agent-skills build system
 */

import { execFileSync } from 'child_process';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const HOOKS_DIR = join(__dirname, 'hooks');

/**
 * Execute a hook script safely using execFile (prevents shell injection)
 */
function runHook(script, context) {
  try {
    const scriptPath = join(HOOKS_DIR, script);
    const result = execFileSync('bash', [scriptPath], {
      cwd: context.workingDir || process.cwd(),
      env: {
        ...process.env,
        TOOL_NAME: context.toolName || '',
        TOOL_INPUT: JSON.stringify(context.toolInput || {}),
        FILE_PATH: context.filePath || '',
      },
      encoding: 'utf-8',
      timeout: context.timeout || 60000,
    });
    return { success: true, output: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Check if tool matches pattern
 */
function matchesTool(toolName, pattern) {
  const patterns = pattern.split('|');
  return patterns.includes(toolName);
}

/**
 * Pre-tool hooks by matcher
 */
const preToolHooks = {
${Object.entries(preToolByMatcher)
  .map(
    ([matcher, hooks]) => `  '${matcher}': [
${hooks.map((h) => `    { id: '${h.id}', script: '${getScriptFilename(h.script)}', timeout: ${h.timeout || 60000} },`).join("\n")}
  ],`
  )
  .join("\n")}
};

/**
 * Post-tool hooks by matcher
 */
const postToolHooks = {
${Object.entries(postToolByMatcher)
  .map(
    ([matcher, hooks]) => `  '${matcher}': [
${hooks.map((h) => `    { id: '${h.id}', script: '${getScriptFilename(h.script)}' },`).join("\n")}
  ],`
  )
  .join("\n")}
};

/**
 * Session hooks
 */
const sessionHooks = {
${sessionHooks.map((h) => `  '${h.event.toLowerCase()}': { id: '${h.id}', script: '${getScriptFilename(h.script)}', timeout: ${h.timeout || 60000} },`).join("\n")}
};

/**
 * Hook handlers
 */
export const hooks = {
  'tool.execute.pre': async (context) => {
    const results = [];
    for (const [matcher, hookList] of Object.entries(preToolHooks)) {
      if (matchesTool(context.toolName, matcher)) {
        for (const hook of hookList) {
          results.push(runHook(hook.script, { ...context, timeout: hook.timeout }));
        }
      }
    }
    return results;
  },

  'tool.execute.post': async (context) => {
    const results = [];
    for (const [matcher, hookList] of Object.entries(postToolHooks)) {
      if (matchesTool(context.toolName, matcher)) {
        for (const hook of hookList) {
          results.push(runHook(hook.script, context));
        }
      }
    }
    return results;
  },

  'session.start': async (context) => {
    if (sessionHooks.sessionstart) {
      return runHook(sessionHooks.sessionstart.script, context);
    }
  },

  'session.end': async (context) => {
    if (sessionHooks.sessionend) {
      return runHook(sessionHooks.sessionend.script, context);
    }
  },
};

export default hooks;
`;
}

/**
 * Get script filename from path
 */
function getScriptFilename(scriptPath) {
  const parts = scriptPath.split("/");
  // Keep the subdirectory structure: pre-tool/script.sh, post-tool/script.sh
  return parts.slice(-2).join("/");
}
