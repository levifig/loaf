---
description: foundations development patterns and best practices
globs:
  - "**/*"
---

---
name: foundations
description: Use for code quality and engineering standards. Covers code style, commit conventions, documentation standards, and security patterns.
---

# Code Standards

Engineering foundations for consistent, secure, and well-documented code.

## Philosophy

**Code speaks first.** Well-structured code with clear names needs fewer comments. When comments are necessary, they explain WHY, not WHAT. Documentation lives close to code but separate from implementation details.

**Commits tell a story.** Each commit represents one coherent change. Messages use imperative mood and focus on intent. The git log should read like a narrative of the project's evolution.

**Security by default.** Every input is untrusted. Every error is generic to users. Every secret is externalized. Defense in depth, not security theater.

## Quick Reference

| Standard | Key Rule | Example |
|----------|----------|---------|
| **Code Style** | Type hints required, structured logging | `async def fetch(id: UUID) -> Result` |
| **Commits** | `<type>: <description>`, imperative mood | `feat: add thermal rating API` |
| **Documentation** | Document after shipping, not before | API docs reflect implemented endpoints only |
| **Security** | Validate all inputs at trust boundaries | Pydantic models at API layer |

## Topics

| Topic | Reference | Use For |
|-------|-----------|---------|
| Code Style | `reference/code-style.md` | Python/TypeScript conventions, naming, patterns |
| Commits | `reference/commits.md` | Commit messages, branches, PRs, Linear integration |
| Documentation | `reference/documentation.md` | ADRs, API docs, changelogs |
| Security | `reference/security.md` | Threat modeling, secrets, compliance |

## Available Scripts

| Script | Usage | Description |
|--------|-------|-------------|
| `scripts/check-commit-msg.sh` | `check-commit-msg.sh <file>` | Validate commit message format |
| `scripts/check-python-style.py` | `check-python-style.py <dir>` | Check Python style (type hints, docstrings) |
| `scripts/check-test-naming.sh` | `check-test-naming.sh <dir>` | Check test file/function naming |
| `scripts/validate-adr.py` | `validate-adr.py <file>` | Validate ADR structure |
| `scripts/check-changelog-format.sh` | `check-changelog-format.sh <file>` | Check micro-changelog format |
| `scripts/check-secrets.sh` | `check-secrets.sh <dir>` | Scan for hardcoded secrets |
| `scripts/validate-compliance.py` | `validate-compliance.py <file>` | Validate security checklist completion |

## Critical Rules

### Always

- Use type hints on all public functions
- Write atomic commits (one logical change)
- Use imperative mood in commit messages
- Validate inputs at trust boundaries
- Log security events (without secrets)
- Include micro-changelog at document bottom

### Never

- Commit secrets, passwords, or API keys
- Document APIs before they ship
- Use bare `except:` clauses
- Force push to main/master
- Log sensitive data or stack traces to users
- Skip commit signing without explicit permission

## Naming Conventions

| Context | Python | TypeScript |
|---------|--------|------------|
| Files | `snake_case.py` | `PascalCase.tsx` (components) |
| Functions | `snake_case` | `camelCase` |
| Classes | `PascalCase` | `PascalCase` |
| Constants | `UPPER_SNAKE` | `UPPER_SNAKE` |
| Tests | `test_<unit>_<scenario>_<result>` | `describe/it` blocks |

## Commit Types

| Type | Use For | Version Impact |
|------|---------|----------------|
| `feat` | New features | Minor bump |
| `fix` | Bug fixes | Patch bump |
| `refactor` | Code restructuring | None |
| `docs` | Documentation only | None |
| `test` | Test additions/updates | None |
| `chore` | Maintenance, deps | None |
| `perf` | Performance improvements | Patch bump |

## Test Patterns

Follow AAA (Arrange-Act-Assert) and scenario-based fixture naming:

- `*_perfect` - Complete, valid data (happy path)
- `*_degraded` - Partial data, quality issues
- `*_chaos` - Edge cases, malformed data

Coverage target: 70% minimum across all components.

## Security Mindset

For every feature, ask:

1. How could this be exploited?
2. What happens if input is malicious?
3. What if authenticated but not authorized?
4. What if the system is partially compromised?

## Related Skills

- `infrastructure-patterns` - Container security, deployment hardening
- `database-patterns` - SQL injection prevention, connection security


## Quality Checks (Manual)

Since Cursor doesn't support automated hooks, run these checks manually:

### Before Committing
- Check for hardcoded secrets before writing
- Validate changelog format
- Check code formatting
- Run security audit on bash commands

### After Changes




---

# Code Style

Coding conventions for Python and TypeScript development.

## Python

### Tooling

| Tool | Purpose | Config |
|------|---------|--------|
| **black** | Formatting | Line length: 100 |
| **isort** | Import sorting | Profile: black |
| **mypy** | Type checking | Strict mode |
| **ruff** | Linting | Replaces flake8 |
| **structlog** | Logging | JSON in production |

### Type Hints (Required)

```python
from typing import Optional
from uuid import UUID

async def get_measurements(
    db: AsyncSession,
    tower_id: UUID,
    start: datetime,
    end: datetime,
    limit: int = 1000,
) -> list[Measurement]:
    """Retrieve measurements within time range."""
    ...
```

### Structured Logging

```python
import structlog

logger = structlog.get_logger(__name__)

# Good: Structured context
logger.info(
    "measurement_processed",
    tower_id=str(tower_id),
    processing_time_ms=elapsed_ms,
)

# Bad: String interpolation
logger.info(f"Processed tower {tower_id}")  # Don't use
```

### Import Organization

```python
# Standard library
from datetime import datetime
from typing import Optional
from uuid import UUID

# Third-party
import structlog
from fastapi import APIRouter, Depends
from pydantic import BaseModel

# Local application
from myproject.core.database import get_db
from myproject.models.tower import Tower
```

### Error Handling

```python
# Define specific exceptions
class ThermalModelError(Exception):
    """Base exception for thermal model errors."""

class ConvergenceError(ThermalModelError):
    """Temperature solution did not converge."""

# Catch specific exceptions
try:
    result = await process_batch(batch)
except ConvergenceError as e:
    logger.warning("convergence_failed", error=str(e))
    result = create_fallback_result(batch)
except Exception as e:
    logger.error("unexpected_error", exc_info=True)
    raise ProcessingError(f"Batch processing failed: {e}") from e
```

## TypeScript

### Tooling

| Tool | Purpose | Config |
|------|---------|--------|
| **Prettier** | Formatting | 2-space, single quotes |
| **ESLint** | Linting | Strict mode |
| **TypeScript** | Type checking | Strict mode |

### Functional Components

```typescript
interface MeasurementCardProps {
  towerId: string;
  timestamp: Date;
  value: number;
  quality?: 'good' | 'degraded' | 'bad';
}

export function MeasurementCard({
  towerId,
  timestamp,
  value,
  quality = 'good',
}: MeasurementCardProps) {
  return (
    <div className={cn('measurement-card', quality)}>
      <span className="value">{value.toFixed(2)}</span>
    </div>
  );
}
```

### Type Definitions

```typescript
// Interface for object shapes
interface Tower {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
}

// Type for unions
type MeasurementType = 'voltage' | 'current' | 'power';

// Generic types
interface ApiResponse<T> {
  data: T;
  meta: { total: number; page: number };
}
```

### Hooks Pattern

```typescript
function useMeasurements(towerId: string) {
  const [measurements, setMeasurements] = useState<Measurement[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let cancelled = false;
    async function fetchData() {
      try {
        const data = await api.getMeasurements(towerId);
        if (!cancelled) setMeasurements(data);
      } catch (err) {
        if (!cancelled) setError(err instanceof Error ? err : new Error('Unknown'));
      } finally {
        if (!cancelled) setIsLoading(false);
      }
    }
    fetchData();
    return () => { cancelled = true; };
  }, [towerId]);

  return { measurements, isLoading, error };
}
```

## Comment Policy

### Hierarchy

1. **Clear Code** - Self-documenting names and structure
2. **Contextual Comments** - Short docstrings, WHY comments
3. **Documentation Files** - ADRs, guides (last resort)

### Good Comments

```python
# Use synchronous I/O here because the async driver
# has a memory leak in high-throughput scenarios.
# See: https://github.com/lib/issues/1234
result = sync_query(data)

# Regulatory requirement: retain for 7 years
# per IEC 62443-2-1 section 4.3.3.6
AUDIT_RETENTION_DAYS = 2555

# TODO(PLT-456): Replace with batch API when available
```

### Bad Comments

```python
i = i + 1  # increment i (obvious)
# old_value = calculate_legacy()  # dead code
x = 86400  # seconds in a day (use constant name)
```

## Test Patterns

### AAA Pattern

```python
async def test_thermal_model_calculates_temperature():
    """Test thermal model returns valid temperature."""
    # Arrange
    input_data = ThermalInput(ambient_temp_c=25.0, wind_speed_mps=2.5)
    model = ThermalModel(conductor=ACSR_DRAKE)

    # Act
    result = await model.calculate(input_data)

    # Assert
    assert result.temperature_c == pytest.approx(75.2, rel=1e-2)
```

### Parameterized Tests

```python
@pytest.mark.parametrize("wind_speed,expected", [
    (0.0, "natural"),
    (0.5, "natural"),
    (0.51, "forced"),
    (10.0, "forced"),
])
def test_convection_type_selection(wind_speed, expected):
    assert select_convection_type(wind_speed) == expected
```

### Test Organization

```
tests/
├── unit/
│   └── services/
├── integration/
│   └── api/
├── e2e/
├── fixtures/
│   └── thermal.py  # *_perfect, *_degraded, *_chaos
└── conftest.py
```


---

# Commit Conventions

Git commit, branch, and pull request standards.

## Commit Message Format

```
<type>: <description>

[optional body]

[optional footer]
```

### Types

| Type | Use For | Version Impact |
|------|---------|----------------|
| `feat` | New features | Minor bump |
| `fix` | Bug fixes | Patch bump |
| `refactor` | Code restructuring | None |
| `perf` | Performance improvements | Patch bump |
| `test` | Test additions/updates | None |
| `docs` | Documentation only | None |
| `chore` | Maintenance, deps, config | None |
| `ci` | CI/CD changes | None |
| `build` | Build system changes | None |

### Description Rules

- **Imperative mood**: "add feature" not "added feature"
- **Lowercase**: Start with lowercase after type
- **No period**: Don't end with a period
- **Short**: Under 72 characters
- **Focus on why**: The diff shows what

### Examples

```bash
# Good
feat: add thermal rating calculation
fix: prevent divide by zero in sag calculation
refactor: extract common validation logic

# Bad
feat: Added thermal rating calculation.  # Past tense, period
fix: Fixed the bug  # Vague, past tense
refactor: refactored code  # Redundant, past tense
```

## Commit Body

Add a body when:
- The "why" isn't obvious from title
- Trade-offs need documenting
- Implementation needs context

```
feat: add CIGRE TB 601 thermal model

Implement steady-state heat balance calculation per CIGRE TB 601.
Uses Newton-Raphson iteration for temperature convergence.

Key implementation notes:
- Natural convection below 0.5 m/s wind speed
- Film temperature for air property evaluation
- Tolerance: 0.1C for convergence
```

### What to Avoid in Body

- File lists (the diff shows this)
- Detailed code explanation
- Agent attribution
- Verbose descriptions

## Linear Integration

Use magic words in footer to link/close issues:

```
feat: add thermal rating API endpoint

Implement GET /api/towers/{id}/thermal-rating endpoint.

Closes BACK-123
```

### Keywords

| Keyword | Effect | Use For |
|---------|--------|---------|
| `Closes BACK-XXX` | Auto-closes on merge | Features, tasks |
| `Fixes BACK-XXX` | Auto-closes on merge | Bug fixes |
| `Resolves BACK-XXX` | Auto-closes on merge | Alternative |
| `Refs BACK-XXX` | Reference only | Related work |
| `Part of BACK-XXX` | Reference only | Partial work |

## Branch Naming

```
<type>/<description>
<type>/TASK-123-description
```

### Types

- `feature/` - New features
- `bugfix/` - Bug fixes
- `hotfix/` - Critical production fixes
- `release/` - Release preparation

### Rules

- Lowercase with hyphens (kebab-case)
- Short but descriptive (max 50 chars)
- Include task ID when applicable

## Pull Request Format

### Title

Same format as commit messages:

```
feat: add thermal rating calculation (#123)
```

### Description Template

```markdown
## Summary

Brief description of what this PR adds/changes and why.

## Changes

- Added thermal rating calculation endpoint
- Implemented CIGRE TB 601 heat balance model
- Added unit tests for thermal model

## Testing

- [ ] Unit tests added/updated
- [ ] Integration tests pass
- [ ] Manual testing performed

## Related Issues

Closes BACK-123
Refs BACK-124
```

## Critical Rules

### Always

- Write atomic commits (one logical change)
- Use imperative mood in messages
- Reference issue numbers when applicable
- Test before committing

### Never

- Skip commit signing (wait for user if it fails)
- Push without explicit user confirmation
- Use scoped commits (`feat(scope):` - use `feat:` instead)
- Include file lists in message
- Add agent attribution
- Mix unrelated changes
- Commit secrets or sensitive data

## Semantic Versioning

```
MAJOR.MINOR.PATCH

1.0.0 -> 1.0.1 (patch: bug fixes)
1.0.1 -> 1.1.0 (minor: new features)
1.1.0 -> 2.0.0 (major: breaking changes)
```

Breaking changes use `feat!:` or `fix!:` and include:

```
BREAKING CHANGE: Description of breaking change.
```


---

# Documentation Review Checklist

Quality checklist for reviewing technical documentation.

## Quick Documentation Check

For every documentation change:

- [ ] Spelling and grammar correct
- [ ] Code examples compile/run
- [ ] Links work
- [ ] No outdated information

## README Review

### Essential Sections

- [ ] **Title** - Clear project name
- [ ] **Description** - What it does in 1-2 sentences
- [ ] **Installation** - How to set up locally
- [ ] **Usage** - Basic example of how to use
- [ ] **Configuration** - Environment variables, options

### Good to Have

- [ ] **Prerequisites** - Required dependencies
- [ ] **Development** - How to contribute
- [ ] **Testing** - How to run tests
- [ ] **License** - Clear licensing info

### Example Structure

```markdown
# Project Name

Brief description of what this project does.

## Installation

\`\`\`bash
npm install project-name
\`\`\`

## Usage

\`\`\`typescript
import { feature } from 'project-name';

const result = feature({ option: 'value' });
\`\`\`

## Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `API_KEY` | Your API key | Required |
| `DEBUG` | Enable debug mode | `false` |

## Development

\`\`\`bash
git clone https://github.com/org/project
cd project
npm install
npm test
\`\`\`

## License

MIT
```

## API Documentation Review

### Endpoint Documentation

Each endpoint should include:

- [ ] **HTTP method and path** - `POST /api/users`
- [ ] **Description** - What it does
- [ ] **Authentication** - Required or not
- [ ] **Request body** - Schema with types
- [ ] **Response** - Success and error schemas
- [ ] **Examples** - Request/response examples

### Example Endpoint Doc

```markdown
## Create User

Creates a new user account.

### Request

`POST /api/users`

**Authentication:** Required (API key)

**Body:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `email` | string | Yes | User's email address |
| `name` | string | Yes | Display name |
| `role` | string | No | User role (default: "user") |

**Example:**

\`\`\`json
{
  "email": "user@example.com",
  "name": "John Doe",
  "role": "admin"
}
\`\`\`

### Response

**Success (201 Created):**

\`\`\`json
{
  "id": "usr_123",
  "email": "user@example.com",
  "name": "John Doe",
  "role": "admin",
  "createdAt": "2024-01-15T10:30:00Z"
}
\`\`\`

**Errors:**

| Status | Code | Description |
|--------|------|-------------|
| 400 | `invalid_email` | Email format invalid |
| 409 | `email_exists` | Email already registered |
| 401 | `unauthorized` | Missing or invalid API key |
```

## Code Comment Review

### Good Comments

- [ ] Explain **why**, not what
- [ ] Document non-obvious behavior
- [ ] Include links to relevant specs/docs
- [ ] Warn about gotchas

### Bad Comments

- [ ] Restating the code
- [ ] Outdated information
- [ ] TODO without context
- [ ] Commented-out code

### Examples

```python
# BAD: Restates code
# Increment counter by 1
counter += 1

# GOOD: Explains why
# Compensate for zero-indexed array
counter += 1

# BAD: No context
# TODO: fix this

# GOOD: Actionable TODO
# TODO(#123): Handle rate limit errors - blocked on auth refactor

# GOOD: Warns about gotcha
# Note: This returns UTC, not local time. Convert if displaying to users.
```

## Changelog Review

### Follows Keep a Changelog

- [ ] Grouped by: Added, Changed, Deprecated, Removed, Fixed, Security
- [ ] Most recent version first
- [ ] Links to version comparisons
- [ ] Dates in ISO format (YYYY-MM-DD)

### Example Changelog

```markdown
# Changelog

## [1.2.0] - 2024-01-15

### Added
- User profile endpoint
- Rate limiting on API

### Changed
- Improved error messages for validation errors

### Fixed
- Memory leak in connection pool (#123)

## [1.1.0] - 2024-01-01

...

[1.2.0]: https://github.com/org/repo/compare/v1.1.0...v1.2.0
[1.1.0]: https://github.com/org/repo/compare/v1.0.0...v1.1.0
```

## Architecture Documentation Review

### ADR (Architecture Decision Record)

- [ ] **Title** - Descriptive name
- [ ] **Status** - Proposed/Accepted/Deprecated/Superseded
- [ ] **Context** - Why this decision was needed
- [ ] **Decision** - What was decided
- [ ] **Consequences** - Trade-offs and impacts

### Example ADR

```markdown
# ADR-001: Use PostgreSQL for primary database

## Status

Accepted

## Context

We need a primary database for user data. Considered options:
- PostgreSQL: Strong ACID, JSON support, mature ecosystem
- MySQL: Familiar, good performance
- MongoDB: Flexible schema, horizontal scaling

## Decision

Use PostgreSQL because:
1. Strong consistency requirements for financial data
2. JSON support for flexible metadata
3. Team expertise

## Consequences

**Positive:**
- Strong data integrity
- Rich query capabilities

**Negative:**
- Less flexible schema evolution
- Vertical scaling primarily
```

## Quality Indicators

### Good Documentation

- Clear, concise language
- Consistent formatting
- Up-to-date with code
- Tested examples
- Accessible to target audience

### Signs of Poor Documentation

- Outdated screenshots
- Broken links
- Untested code samples
- Jargon without explanation
- Missing error scenarios

---

*Reference: [Write the Docs](https://www.writethedocs.org/guide/), [Google Technical Writing](https://developers.google.com/tech-writing)*


---

# Documentation Standards

Guidelines for technical documentation, ADRs, and API docs.

## Core Principle

**Document after shipping, not before.**

API documentation reflects ONLY what is implemented and released. Future features belong in Linear issues, not docs.

## Document Hierarchy

```
docs/
├── PRD.md                # What the product should be (vision)
├── ARCHITECTURE.md       # How the product is built (design)
├── IMPLEMENTATION.md     # What the product currently is (status)
├── QUICK_REFERENCE.md    # One-page command reference
├── api/                  # API docs (implemented features only)
│   ├── openapi.yaml
│   └── endpoints/
└── decisions/            # Architecture Decision Records
    ├── ADR000-template.md
    └── ADR001-*.md
```

## Document Separation

| Document | Purpose | Updates When |
|----------|---------|--------------|
| **PRD.md** | Product vision (timeless) | Vision changes |
| **ARCHITECTURE.md** | Technical design | Architecture changes |
| **IMPLEMENTATION.md** | Current status | Features ship |
| **API docs** | Implemented endpoints | Features ship |

## Architecture Decision Records (ADRs)

### When to Write

| Write ADR | Skip ADR |
|-----------|----------|
| Technology choices | Library version updates |
| Architectural patterns | Bug fixes |
| Integration approaches | Performance tweaks |
| Security decisions | Code style changes |

### File Naming

```
docs/decisions/ADRXXX-short-descriptive-title.md
```

Example: `ADR001-postgresql-only-no-redis.md`

### Template

```markdown
# ADR-XXX: Title

**Decision Date**: YYYY-MM-DD

**Status**: Proposed | Accepted | Deprecated | Superseded

## Context

[Describe the situation and problem. What constraints exist?]

## Decision

[State the decision clearly. Use "We will..." not "It was decided..."]

## Consequences

### Positive
- [Benefit 1]

### Negative
- [Drawback 1]

## Alternatives Considered

### Alternative 1: [Name]
[Brief description and why rejected]
```

### Status Lifecycle

```
Proposed -> Accepted -> (Deprecated | Superseded)
```

## API Documentation

### The Implemented-Only Rule

```
Feature Request -> Implementation -> Tests Pass -> Release -> Update API Docs
                                                                     ^
                                                               Only here!
```

### OpenAPI Spec

```yaml
openapi: 3.1.0
info:
  title: Project API
  version: 1.2.0  # Matches actual release version
  description: |
    **Last Updated**: 2025-11-14
```

### Deprecation

```yaml
paths:
  /api/v1/legacy-endpoint:
    get:
      deprecated: true
      summary: Legacy endpoint (use /api/v2/new-endpoint)
      description: |
        **Deprecated since**: v1.5.0
        **Removal planned**: v2.0.0
```

## Micro-Changelog

Track changes within individual documents.

### Placement

Always at the **bottom** of the document:

```markdown
# Document Title

[Content...]

---

## Changelog

- 2025-11-14 - Added section on agent instructions
- 2025-11-12 - Updated architecture overview
- 2025-11-10 - Initial document creation
```

### Format Rules

- **Date format**: `YYYY-MM-DD`
- **Order**: Reverse chronological (newest first)
- **Entry format**: `- YYYY-MM-DD - Short description`
- **Single line**: Per entry

### What to Log

| DO Log | DON'T Log |
|--------|-----------|
| Section additions | Typo fixes |
| Significant updates | Formatting changes |
| Restructuring | Link updates |
| Corrections | Minor wording |
| Deprecations | |

### Header Pairing

```markdown
# Architecture Overview

**Last Updated**: 2025-11-14

[Content...]

---

## Changelog
- 2025-11-14 - ...
```

## Critical Rules

### Always

- Include Last Updated timestamp (YYYY-MM-DD)
- Add micro-changelog at document bottom
- Reference files, not inline code
- Keep docs minimal - delete cruft

### Never

- Document APIs before they ship
- Include session/council file references
- Use lengthy code samples in docs
- Add planning details to docs (use Linear)


---

# Code Review Checklist

Comprehensive code review checklist for ensuring code quality, maintainability, and correctness.

## Quick Review (< 5 minutes)

Use for small PRs (< 50 lines):

- [ ] Code compiles and tests pass
- [ ] Naming is clear and descriptive
- [ ] No obvious bugs or logic errors
- [ ] No hardcoded secrets or credentials

## Standard Review (5-15 minutes)

Use for typical PRs:

### Code Quality
- [ ] Functions have single responsibility
- [ ] No deeply nested logic (max 3 levels)
- [ ] No magic numbers (use named constants)
- [ ] No commented-out code
- [ ] Error messages are helpful

### Naming & Readability
- [ ] Variables describe what they hold
- [ ] Functions describe what they do
- [ ] Classes represent clear concepts
- [ ] Abbreviations are avoided or well-known

### Type Safety
- [ ] All function parameters have types
- [ ] Return types are explicit
- [ ] No `any` types (TypeScript) or missing hints (Python)
- [ ] Generics used appropriately

### Error Handling
- [ ] Errors don't fail silently
- [ ] Error messages include context
- [ ] Resources cleaned up on error
- [ ] Appropriate error types used

## Deep Review (15-30 minutes)

Use for critical paths, security-sensitive code, or architectural changes:

### Architecture
- [ ] Follows existing patterns in codebase
- [ ] Abstractions are at right level
- [ ] Dependencies flow in correct direction
- [ ] No circular dependencies
- [ ] Changes are backwards compatible

### Performance
- [ ] No N+1 queries
- [ ] Expensive operations cached when appropriate
- [ ] No unnecessary allocations in hot paths
- [ ] Pagination for large data sets

### Security
- [ ] Input validated at boundaries
- [ ] Output encoded appropriately
- [ ] SQL uses parameterized queries
- [ ] Authentication/authorization checked
- [ ] Secrets not logged or exposed

### Testing
- [ ] New code has tests
- [ ] Tests are meaningful (not just coverage)
- [ ] Edge cases covered
- [ ] Error paths tested
- [ ] Tests don't depend on execution order

### Documentation
- [ ] Public APIs documented
- [ ] Complex algorithms explained
- [ ] Non-obvious decisions commented
- [ ] README updated if needed

## Review Response Templates

### Approve

```
LGTM!

Minor suggestions (optional):
- [suggestion]

The implementation is clean and well-tested.
```

### Request Changes

```
Good progress. A few items to address:

**Must fix:**
- [blocking issue]

**Should fix:**
- [important but not blocking]

**Consider:**
- [optional improvement]

Happy to discuss any of these.
```

### Need More Context

```
I need more context to review this effectively:

- What problem is this solving?
- What alternatives were considered?
- How was this tested?

Could you update the PR description?
```

## Common Issues to Flag

### Always Flag
- Hardcoded secrets
- SQL injection vulnerabilities
- Missing input validation
- Unbounded loops or recursion
- Memory leaks
- Race conditions

### Usually Flag
- Missing error handling
- No tests for new code
- Magic numbers
- Overly complex functions
- Copy-pasted code

### Consider Flagging
- Inconsistent style
- Missing type annotations
- Verbose code that could be simplified
- Missing documentation for public APIs

## Review Mindset

1. **Assume good intent** - reviewer and author want the same thing
2. **Be specific** - point to exact lines, provide examples
3. **Explain why** - don't just say "change this", explain the reason
4. **Offer alternatives** - suggest better approaches, don't just criticize
5. **Separate blocking from optional** - be clear about what must change
6. **Timebox** - don't spend hours on minor PRs

---

*Reference: [foundations/code-style](./code-style.md) for style guidelines*

