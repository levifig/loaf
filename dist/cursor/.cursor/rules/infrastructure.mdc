---
description: infrastructure development patterns and best practices
globs:
  - "**/Dockerfile*"
  - "**/*.yaml"
  - "**/*.yml"
  - "**/terraform/**/*"
---

---
name: infrastructure
description: Use for infrastructure and DevOps work. Covers Docker, Kubernetes, GitOps, CI/CD pipelines, and troubleshooting.
---

# Infrastructure

Infrastructure patterns for containerization, orchestration, CI/CD pipelines, and deployment automation.

## Stack Overview

| Layer | Technologies |
|-------|--------------|
| Containers | Docker, BuildKit, multi-stage builds |
| Orchestration | Kubernetes, Helm, Kustomize |
| GitOps | ArgoCD, Flux, Argo Rollouts |
| CI/CD | GitHub Actions, GitLab CI |
| Registries | GHCR, ECR, GCR, DockerHub |

## Philosophy

1. **Infrastructure as Code** - All configuration in version control
2. **GitOps** - Git as the single source of truth for deployments
3. **Security by Default** - Non-root, minimal images, no secrets in code
4. **Observability** - Health checks, probes, structured logging
5. **Reproducibility** - Pinned versions, lockfiles, deterministic builds

## Quick Reference

### Docker Essentials

```dockerfile
# Multi-stage build with non-root user
FROM python:3.12-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

FROM python:3.12-slim
RUN useradd --uid 1000 --create-home appuser
COPY --from=builder /install /usr/local
COPY --chown=appuser:appuser . .
USER appuser
HEALTHCHECK --interval=30s --timeout=3s CMD curl -f http://localhost:8000/health || exit 1
ENTRYPOINT ["python", "-m", "app"]
```

### Kubernetes Pod Spec

```yaml
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
  containers:
    - name: app
      image: app:v1.0.0  # Never :latest
      resources:
        requests: {memory: "256Mi", cpu: "100m"}
        limits: {memory: "512Mi", cpu: "500m"}
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
      livenessProbe:
        httpGet: {path: /health, port: 8000}
        initialDelaySeconds: 10
      readinessProbe:
        httpGet: {path: /ready, port: 8000}
        initialDelaySeconds: 5
```

### GitHub Actions Cache

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
    restore-keys: |
      ${{ runner.os }}-pip-
```

## Topics

| Topic | Reference File | Description |
|-------|----------------|-------------|
| Docker | `reference/docker.md` | Multi-stage builds, layers, security, health checks |
| Kubernetes | `reference/kubernetes.md` | Deployments, services, probes, resources, secrets |
| GitOps | `reference/gitops.md` | ArgoCD, Kustomize, sync policies, rollout strategies |
| CI/CD | `reference/ci-cd.md` | GitHub Actions workflows, caching, secrets, matrix builds |
| Troubleshooting | `reference/troubleshooting.md` | CI failures, version conflicts, cache issues |

## Available Scripts

| Script | Usage | Description |
|--------|-------|-------------|
| `scripts/check-dockerfile.sh` | `check-dockerfile.sh <file>` | Validate Dockerfile best practices |
| `scripts/validate-k8s-manifest.py` | `validate-k8s-manifest.py <file>` | Check K8s manifest for required fields |

## Critical Rules

### Always

- Use multi-stage builds to minimize image size
- Run containers as non-root user (UID 1000)
- Include health checks in all services
- Pin specific image versions (no `:latest`)
- Set resource requests AND limits
- Use `npm ci` / `pip-sync` in CI (not install)
- Commit lockfiles to version control

### Never

- Commit secrets to version control
- Use `:latest` tags in production
- Skip security scanning in CI
- Deploy without rollback capability
- Store state in containers
- Run as root in production

## CI Failure Triage

```
CI Failed
+-- Same code passes locally?
|   +-- YES --> Check environment differences
|   |   +-- Python/Node version
|   |   +-- Environment variables
|   |   +-- File permissions
|   |   +-- Installed dependencies
|   +-- NO --> Fix the actual bug
+-- Flaky (sometimes passes)?
|   +-- Check for race conditions, shared state, timeouts
+-- Always fails in CI?
    +-- Check runner resources (memory, timeout)
    +-- Check external service access
    +-- Check CI-specific config
```

## Quick Diagnostics

```bash
# Check local vs CI Python version
python --version

# Check installed package versions
pip freeze | grep -E "(pytest|mypy|black|ruff)"

# Check Node/npm versions
node --version && npm --version

# Compare lockfile changes
git diff origin/main -- package-lock.json requirements*.txt
```


## Quality Checks (Manual)

Since Cursor doesn't support automated hooks, run these checks manually:

### Before Committing
- Validate Kubernetes manifests
- Lint Dockerfile
- Kubernetes dry-run validation
- Terraform plan with cost estimation

### After Changes




---

# CI/CD Patterns

Best practices for continuous integration and deployment pipelines.

## GitHub Actions Workflow

```yaml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - run: pip install ruff mypy
      - run: ruff check . && ruff format --check .
      - run: mypy .

  test:
    runs-on: ubuntu-latest
    needs: lint
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"
      - run: pip install -e ".[test]"
      - run: pytest --cov --cov-report=xml
        env:
          DATABASE_URL: postgresql://postgres:test@localhost:5432/test

  build:
    runs-on: ubuntu-latest
    needs: [test]
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

## Pipeline Stages

```
Lint --> Test --> Security --> Build --> Deploy
```

| Stage | Purpose | Fail Fast |
|-------|---------|-----------|
| Lint | Code style, formatting | Yes |
| Test | Unit, integration tests | Yes |
| Security | Vulnerability scanning | Yes |
| Build | Container image creation | No (main only) |
| Deploy | Environment deployment | No (manual gate) |

## Caching Strategies

### Python Dependencies

```yaml
- uses: actions/setup-python@v5
  with:
    python-version: "3.12"
    cache: "pip"
    cache-dependency-path: |
      requirements.txt
      requirements-dev.txt
```

### Docker Layer Caching

```yaml
- uses: docker/build-push-action@v5
  with:
    cache-from: type=gha
    cache-to: type=gha,mode=max
```

### Custom Caching

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.cache/pre-commit
    key: pre-commit-${{ hashFiles('.pre-commit-config.yaml') }}
```

## Secrets Management

```yaml
# Repository/environment secrets
env:
  DATABASE_URL: ${{ secrets.DATABASE_URL }}

# Environment-specific
deploy:
  environment: production  # Uses production secrets
```

| Type | Use Case |
|------|----------|
| Repository secrets | Shared across workflows |
| Environment secrets | Per-environment (staging/prod) |
| Organization secrets | Shared across repos |

## Matrix Builds

```yaml
test:
  strategy:
    fail-fast: false  # Run all combinations
    matrix:
      python-version: ["3.11", "3.12"]
      os: [ubuntu-latest, macos-latest]
  runs-on: ${{ matrix.os }}
  steps:
    - uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
```

## GitOps Deployment

```yaml
deploy:
  needs: build
  steps:
    - uses: actions/checkout@v4
      with:
        repository: org/gitops
        token: ${{ secrets.GITOPS_TOKEN }}
    - run: |
        yq -i '.spec.template.spec.containers[0].image = "app:${{ github.sha }}"' \
          apps/production/deployment.yaml
    - run: |
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git commit -am "Deploy ${{ github.sha }}"
        git push
```

## Reusable Workflows

```yaml
# Call
jobs:
  call-workflow:
    uses: org/shared-workflows/.github/workflows/python-ci.yml@main
    with:
      python-version: "3.12"
    secrets: inherit

# Define
on:
  workflow_call:
    inputs:
      python-version:
        required: true
        type: string
```

## Debugging

```yaml
- name: Debug Environment
  run: |
    echo "Python: $(python --version)"
    echo "Working dir: $(pwd)"
    env | sort

# Enable debug logging
# Set repository secrets:
# ACTIONS_RUNNER_DEBUG: true
# ACTIONS_STEP_DEBUG: true
```

## Checklist

- [ ] Lint and type check before tests
- [ ] Security scanning in pipeline
- [ ] Tests run with real database
- [ ] Coverage reports uploaded
- [ ] Docker caching enabled
- [ ] Secrets not in workflow files
- [ ] Concurrency control
- [ ] Environment gates for production


---

# Docker Patterns

Best practices for building production-ready container images.

## Multi-Stage Builds

Separate build dependencies from runtime to minimize image size and attack surface.

```dockerfile
# Stage 1: Build
FROM python:3.12-slim AS builder
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential && rm -rf /var/lib/apt/lists/*
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# Stage 2: Runtime
FROM python:3.12-slim
RUN useradd --uid 1000 --create-home appuser
COPY --from=builder /install /usr/local
WORKDIR /app
COPY --chown=appuser:appuser . .
USER appuser
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1
ENTRYPOINT ["python", "-m", "app"]
```

## Layer Optimization

Order instructions from least to most frequently changing:

```dockerfile
# Good: Dependencies before code
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

# Bad: Busts cache on every code change
COPY . .
RUN pip install -r requirements.txt
```

Combine RUN commands and clean up:

```dockerfile
# Good: Single RUN with cleanup
RUN apt-get update \
    && apt-get install -y --no-install-recommends curl \
    && rm -rf /var/lib/apt/lists/*
```

## Non-Root User

```dockerfile
# Create user with specific UID for K8s compatibility
RUN useradd --uid 1000 --create-home --shell /bin/bash appuser
COPY --chown=appuser:appuser . .
USER appuser
```

**Why UID 1000?** Matches Kubernetes `runAsUser: 1000`, avoids volume mount permissions issues.

## Health Checks

```dockerfile
# HTTP health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Process health check
HEALTHCHECK --interval=30s --timeout=3s \
    CMD pgrep -x python || exit 1
```

| Parameter | Value | Purpose |
|-----------|-------|---------|
| `--interval` | 30s | Time between checks |
| `--timeout` | 3s | Max time for check |
| `--start-period` | 5s | Grace period for startup |
| `--retries` | 3 | Failures before unhealthy |

## Base Images

| Image | Size | Use Case |
|-------|------|----------|
| `scratch` | 0MB | Static Go binaries |
| `distroless` | ~2MB | Compiled languages |
| `alpine` | ~5MB | Need shell/packages |
| `*-slim` | ~50MB | Need glibc |

```dockerfile
# For static binaries
FROM gcr.io/distroless/static-debian12:nonroot
COPY --from=builder /app/server /
USER nonroot:nonroot
ENTRYPOINT ["/server"]
```

## Secrets Management

Never bake secrets into images:

```dockerfile
# BuildKit secret mount (build-time only)
RUN --mount=type=secret,id=pip_conf,target=/etc/pip.conf \
    pip install --no-cache-dir -r requirements.txt

# Runtime: docker run -e DATABASE_PASSWORD="$SECRET" app
```

## Environment Variables

```dockerfile
# Build-time only (not in final image)
ARG BUILD_VERSION

# Runtime (available in container)
ENV APP_VERSION=${BUILD_VERSION}
ENV LOG_LEVEL=INFO
ENV PYTHONUNBUFFERED=1
```

## .dockerignore

```
.git
__pycache__
*.pyc
.pytest_cache
.mypy_cache
.venv
.env
*.local.*
Dockerfile*
docker-compose*
```

## Checklist

- [ ] Multi-stage build used
- [ ] Non-root user (UID 1000)
- [ ] Health check defined
- [ ] No secrets in image
- [ ] Specific version tags
- [ ] .dockerignore present
- [ ] Layer order optimized
- [ ] apt lists cleaned up
- [ ] PYTHONUNBUFFERED=1 set


---

# GitOps Patterns

GitOps workflows with ArgoCD, Kustomize, and deployment strategies.

## Core Principles

1. **Declarative** - System described declaratively in Git
2. **Versioned** - Git as single source of truth
3. **Automated** - Approved changes applied automatically
4. **Auditable** - All changes traceable through commits

## Repository Structure

```
gitops-repo/
+-- apps/
|   +-- base/                # Base configurations
|   +-- overlays/            # Environment-specific
|       +-- dev/
|       +-- prod/
+-- clusters/                # Cluster configs
+-- infrastructure/          # Shared components
```

## ArgoCD Application

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/org/repo.git
    targetRevision: main
    path: apps/overlays/prod
  destination:
    server: https://kubernetes.default.svc
    namespace: my-app
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

## Kustomize Overlay

```yaml
# apps/overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: my-app-prod
resources:
  - ../../base
images:
  - name: my-app
    newTag: v1.2.3
replicas:
  - name: my-app
    count: 3
```

## Helm with ArgoCD

```yaml
spec:
  source:
    repoURL: https://charts.example.com
    chart: my-chart
    targetRevision: 2.1.0
    helm:
      valueFiles:
        - values-prod.yaml
```

## Deployment Strategies

### Blue/Green

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
spec:
  strategy:
    blueGreen:
      activeService: my-app-active
      previewService: my-app-preview
      autoPromotionEnabled: false
```

### Canary

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
spec:
  strategy:
    canary:
      steps:
        - setWeight: 10
        - pause: {duration: 5m}
        - setWeight: 50
        - analysis:
            templates:
              - templateName: success-rate
        - setWeight: 100
```

## Sync Policies

| Policy | Use Case |
|--------|----------|
| `prune: true` | Remove resources not in Git |
| `selfHeal: true` | Revert manual changes |
| `ApplyOutOfSyncOnly=true` | Sync only changed resources |

## Best Practices

- Use **sealed-secrets** or **external-secrets** for sensitive data
- Use **ApplicationSets** for multi-cluster deployments
- Set **sync waves** for dependency ordering (`argocd.argoproj.io/sync-wave: "1"`)
- Configure **resource hooks** for migrations (`argocd.argoproj.io/hook: PreSync`)

## GitOps Workflow

```
Code Change --> PR --> Review --> Merge to main
                                      |
                                      v
ArgoCD detects change --> Sync --> Kubernetes
                                      |
                                      v
                              Health checks pass
```

## Checklist

- [ ] Git repo as single source of truth
- [ ] Environment-specific overlays
- [ ] Automated sync enabled
- [ ] Secrets encrypted (sealed-secrets)
- [ ] Sync waves for dependencies
- [ ] Rollback strategy defined


---

# Kubernetes Patterns

Best practices for Kubernetes deployments, services, and configuration.

## Pod Security Context

```yaml
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  containers:
    - name: app
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop: [ALL]
```

| Setting | Purpose |
|---------|---------|
| `runAsNonRoot: true` | Prevents running as root |
| `runAsUser: 1000` | Matches Dockerfile user |
| `allowPrivilegeEscalation: false` | Prevents privilege escalation |
| `readOnlyRootFilesystem: true` | Prevents filesystem modifications |
| `capabilities.drop: ALL` | Removes all Linux capabilities |

## Resource Management

```yaml
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"
```

| Workload Type | Memory Request | Memory Limit | CPU Request | CPU Limit |
|---------------|----------------|--------------|-------------|-----------|
| API Service | 256Mi | 512Mi | 100m | 500m |
| Background Worker | 512Mi | 1Gi | 200m | 1000m |
| Batch Job | 1Gi | 2Gi | 500m | 2000m |

**QoS Classes:** Guaranteed (requests==limits) > Burstable (requests<limits) > BestEffort (none)

## Health Probes

```yaml
livenessProbe:        # Restart if fails
  httpGet: {path: /health, port: 8000}
  initialDelaySeconds: 10
  periodSeconds: 30
  failureThreshold: 3

readinessProbe:       # Remove from service if fails
  httpGet: {path: /ready, port: 8000}
  initialDelaySeconds: 5
  periodSeconds: 10

startupProbe:         # For slow-starting apps
  httpGet: {path: /health, port: 8000}
  failureThreshold: 30
  periodSeconds: 5     # 30 * 5s = 150s max startup
```

## ConfigMaps and Secrets

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  LOG_LEVEL: "INFO"
  config.yaml: |
    database:
      pool_size: 10
---
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  DATABASE_URL: "postgres://user:pass@host/db"
```

**Usage in pods:**

```yaml
envFrom:
  - configMapRef: {name: app-config}
  - secretRef: {name: app-secrets}
```

## Service Types

| Type | Use Case |
|------|----------|
| `ClusterIP` | Internal services (default) |
| `NodePort` | Dev/test external access |
| `LoadBalancer` | Production external access |

```yaml
apiVersion: v1
kind: Service
spec:
  type: ClusterIP
  selector: {app: app}
  ports:
    - port: 80
      targetPort: 8000
```

## Deployment Strategies

```yaml
# Rolling Update (default)
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 25%
```

## Horizontal Pod Autoscaling

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target: {type: Utilization, averageUtilization: 70}
```

## Network Policies

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
spec:
  podSelector:
    matchLabels: {app: app}
  policyTypes: [Ingress, Egress]
  ingress:
    - from:
        - podSelector: {matchLabels: {app: frontend}}
      ports: [{port: 8000}]
```

## StatefulSets vs Deployments

**Use StatefulSet when:**
- Stable network identity needed (pod-0, pod-1)
- Persistent storage per pod
- Ordered deployment/scaling
- Examples: databases, message queues

**Use Deployment when:**
- Stateless workloads
- Any pod can handle any request
- Examples: APIs, web servers

## Labels and Annotations

```yaml
metadata:
  labels:
    app.kubernetes.io/name: myapp
    app.kubernetes.io/component: api
    app.kubernetes.io/version: "1.0.0"
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8000"
```

## Checklist

- [ ] Security context configured
- [ ] runAsNonRoot: true
- [ ] Resource requests AND limits set
- [ ] Liveness and readiness probes defined
- [ ] Secrets not in ConfigMaps
- [ ] No `latest` image tags
- [ ] Labels follow Kubernetes conventions


---

# CI/CD Troubleshooting

Debugging CI failures, version conflicts, environment differences, and cache issues.

## Triage Decision Tree

```
CI Failed
+-- Same code passes locally?
|   +-- YES --> Check environment differences
|   |   +-- Python/Node version
|   |   +-- Environment variables
|   |   +-- File permissions
|   |   +-- Installed dependencies
|   +-- NO --> Fix the actual bug
+-- Flaky (sometimes passes)?
|   +-- Check for race conditions, shared state, timeouts
+-- Always fails in CI?
    +-- Check runner resources (memory, timeout)
    +-- Check external service access
    +-- Check CI-specific config
```

## Quick Diagnostics

```bash
# Check local versions
python --version
pip freeze | grep -E "(pytest|mypy|black|ruff)"
node --version && npm --version

# Compare lockfile changes
git diff origin/main -- package-lock.json requirements*.txt
```

## Common Failure Categories

| Symptom | Likely Cause | First Check |
|---------|--------------|-------------|
| Tests pass locally, fail in CI | Environment difference | Python/Node version, env vars |
| Linter passes locally, fails in CI | Version mismatch | Lock file, tool version |
| Random failures | Flaky test or race condition | Run tests multiple times |
| Timeout | Resource limits or hanging test | CI runner specs |
| Permission denied | File permissions or docker | Check container user |

## Version Conflicts

### Diagnosis

```yaml
# Add to workflow for debugging
- name: Show versions
  run: |
    python --version
    pip freeze
    node --version
    npm list
```

### Common Issues

**mypy/black/ruff version mismatch:**
```toml
# Pin exact versions in pyproject.toml
[tool.poetry.dev-dependencies]
mypy = "1.8.0"
black = "24.1.1"
ruff = "0.1.14"
```

**ESLint v8 to v9:** Different config format (flat config)

### Lockfile Best Practices

```bash
# Python: Use exact versions
pip-compile --generate-hashes requirements.in
pip install -r requirements.txt --no-deps

# Node: Use lockfile exactly
npm ci  # Not npm install
```

## Environment Differences

### Common Missing Variables

| Variable | Local | CI | Impact |
|----------|-------|-----|--------|
| `TZ` | Local timezone | UTC | Time-dependent tests |
| `PYTHONPATH` | Project root | Not set | Import errors |
| `HOME` | Your home | `/home/runner` | Config file paths |

### Fix: Set Consistent Environment

```yaml
env:
  TZ: UTC
  PYTHONPATH: ${{ github.workspace }}
  PYTHONUNBUFFERED: 1
  NODE_ENV: test
```

### OS Differences (macOS vs Linux)

| Aspect | macOS | Linux CI |
|--------|-------|----------|
| File system | Case-insensitive | Case-sensitive |
| Temp dir | /var/folders/... | /tmp |
| Home dir | /Users/you | /home/runner |

```python
# This works on macOS, fails on Linux:
from MyModule import MyClass  # File is mymodule.py
```

## Cache Issues

### Common Problems

**Stale cache:**
```yaml
# Force invalidation with version suffix
key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-v2
```

**Cache miss when expected hit:**
- Hash includes files that changed
- Branch scope prevents matching
- Cache evicted (7 day TTL)

**Wrong dependencies despite cache hit:**
```yaml
# Include all dependency files in hash
key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
```

### Debug Cache

```yaml
- uses: actions/cache@v4
  id: cache
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}

- run: echo "Cache hit: ${{ steps.cache.outputs.cache-hit }}"

- name: Check cache contents
  if: steps.cache.outputs.cache-hit == 'true'
  run: ls -la ~/.cache/pip/ && du -sh ~/.cache/pip/
```

### Force Cache Invalidation

```bash
# Via API
gh api repos/{owner}/{repo}/actions/caches
gh api -X DELETE repos/{owner}/{repo}/actions/caches/{cache_id}
```

## GitHub Actions Debugging

### Add Debug Output

```yaml
- name: Debug Environment
  run: |
    echo "=== Environment ==="
    env | sort
    echo "=== Python ==="
    python --version && which python
    echo "=== Directory ==="
    pwd && ls -la
```

### Enable Debug Logging

Set repository secrets:
- `ACTIONS_RUNNER_DEBUG: true`
- `ACTIONS_STEP_DEBUG: true`

Or re-run with "Enable debug logging" checked.

### SSH Access for Debugging

```yaml
- name: Setup tmate session
  if: ${{ failure() }}
  uses: mxschmitt/action-tmate@v3
  with:
    limit-access-to-actor: true
```

## Resolution Checklist

- [ ] Python/Node version matches
- [ ] All dependencies at same version
- [ ] Environment variables set
- [ ] Working directory correct
- [ ] File permissions correct
- [ ] Services running (database, etc.)
- [ ] Cache not stale
- [ ] Tests run in same order
- [ ] No local uncommitted changes affecting test

