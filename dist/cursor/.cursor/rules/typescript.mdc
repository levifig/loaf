---
description: typescript development patterns and best practices
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/tsconfig*.json"
  - "**/package.json"
---

---
name: typescript
description: Use for all TypeScript and React development. Covers project setup, React patterns, Next.js, state management, forms, API integration, testing, styling, performance, accessibility, mobile development, and ESM patterns.
---

# TypeScript Development

Comprehensive guide for modern TypeScript development with React ecosystem.

## When to Use This Skill

- Starting or configuring TypeScript projects
- Building React components and applications
- Working with Next.js 14+ and App Router
- Implementing state management patterns
- Building forms with validation
- Integrating APIs and handling data fetching
- Writing tests for TypeScript applications
- Styling with Tailwind and CVA
- Optimizing application performance
- Implementing accessibility (a11y)
- Building React Native mobile apps
- Working with modern JavaScript (ESM)

## Stack Overview

| Layer | Default | Alternatives |
|-------|---------|--------------|
| Language | TypeScript 5+ | JavaScript (ESM) |
| Runtime | Node.js 20+ | Bun, Deno |
| Framework | Next.js 14+ | Vite, Remix |
| UI Library | React 18+ | - |
| State (Client) | Zustand | Context + Reducer |
| State (Server) | React Query | SWR |
| Forms | React Hook Form + Zod | - |
| Styling | Tailwind CSS + CVA | CSS Modules |
| Testing | Vitest + RTL | Jest |
| E2E Testing | Playwright | Cypress |
| Package Manager | pnpm | npm, yarn |

## Core Philosophy

- **Strict mode always** - catch errors at compile time
- **Server Components by default** - use Client Components only when needed
- **Type inference** - let TypeScript infer when obvious
- **Server state is different** - use React Query for API data
- **Accessibility is mandatory** - not optional
- **Mobile-first responsive** - design for small screens first
- **Measure before optimizing** - profile, then fix

## Quick Reference

### Project Setup

```json
// tsconfig.json essentials
{
  "compilerOptions": {
    "target": "ES2022",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "moduleResolution": "bundler"
  }
}
```

### Component Pattern

```typescript
interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
  variant?: "primary" | "secondary";
}

export function Button({ children, onClick, variant = "primary" }: ButtonProps) {
  return (
    <button onClick={onClick} className={`btn btn-${variant}`}>
      {children}
    </button>
  );
}
```

### Server Component (Next.js)

```typescript
// Server Component by default - no "use client"
export default async function PostsPage() {
  const posts = await fetch("https://api.example.com/posts").then(r => r.json());
  return <PostList posts={posts} />;
}
```

### Client Component

```typescript
"use client";

import { useState } from "react";

export function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>;
}
```

### Form with Zod Validation

```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

type FormData = z.infer<typeof schema>;

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(schema),
  });
  // ...
}
```

### React Query for API Data

```typescript
import { useQuery } from "@tanstack/react-query";

export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: () => fetch("/api/users").then(r => r.json()),
    staleTime: 5 * 60 * 1000,
  });
}
```

### CVA for Type-Safe Variants

```typescript
import { cva, type VariantProps } from "class-variance-authority";

const button = cva("rounded-md font-medium", {
  variants: {
    variant: { primary: "bg-blue-600 text-white", secondary: "bg-gray-200" },
    size: { sm: "px-3 py-2 text-sm", md: "px-4 py-2", lg: "px-6 py-3" },
  },
  defaultVariants: { variant: "primary", size: "md" },
});

type ButtonProps = VariantProps<typeof button>;
```

## Topics

| Topic | Use For |
|-------|---------|
| [Core](reference/core.md) | Project setup, tsconfig, modern TS features, type utilities |
| [React](reference/react.md) | Components, hooks, Context API, performance patterns |
| [Next.js](reference/nextjs.md) | App Router, Server/Client Components, Server Actions, routing |
| [Types](reference/types.md) | Advanced types, generics, conditional types, type guards |
| [State](reference/state.md) | Zustand, React Query, Context + Reducer, URL state |
| [Forms](reference/forms.md) | React Hook Form, Zod validation, Server Actions integration |
| [API](reference/api.md) | Fetch wrappers, React Query, tRPC, GraphQL, WebSockets |
| [Testing](reference/testing.md) | Vitest, React Testing Library, MSW, Playwright E2E |
| [Styling](reference/styling.md) | Tailwind CSS, CVA variants, dark mode, responsive design |
| [Performance](reference/performance.md) | Bundle analysis, code splitting, memoization, Web Vitals |
| [Accessibility](reference/a11y.md) | WCAG compliance, ARIA, keyboard navigation, screen readers |
| [Mobile](reference/mobile.md) | React Native, Expo, navigation, platform-specific code |
| [ESM](reference/esm.md) | ESM patterns, JSDoc types, JS vs TS decision guide |

## Critical Rules

### Always

- Use strict mode in tsconfig
- Type all function parameters and returns
- Handle null/undefined explicitly
- Use Server Components by default
- Validate on both client and server
- Test with screen readers
- Measure before optimizing

### Never

- Use `any` (use `unknown` with type guards)
- Use `!` (non-null assertion) without justification
- Store server data in client state (use React Query)
- Rely on color alone for information
- Create new functions in render
- Skip error handling for API calls
- Premature optimization


## Quality Checks (Manual)

Since Cursor doesn't support automated hooks, run these checks manually:

### Before Committing
- Run TypeScript compiler check
- Analyze bundle size impact

### After Changes
- Run ESLint after changes



---

# Accessibility (A11y)

Building inclusive, accessible web applications.

## WCAG 2.1 Standards

### Level AA (Target)
- Contrast ratio 4.5:1 for normal text
- Contrast ratio 3:1 for large text
- Focus visible on all interactive elements
- All content keyboard accessible

## Semantic HTML

```typescript
// ❌ Non-semantic
<div className="nav">
  <div onClick={() => navigate("/")} className="nav-item">Home</div>
</div>

// ✅ Semantic HTML
<nav aria-label="Main navigation">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>

// Proper heading hierarchy
<article>
  <h1>Article Title</h1>
  <section>
    <h2>Section Title</h2>
    <h3>Subsection</h3>
  </section>
</article>

// Landmark regions
<header>
  <nav aria-label="Main">{/* Nav */}</nav>
</header>
<main>{/* Content */}</main>
<aside aria-label="Related">{/* Sidebar */}</aside>
<footer>{/* Footer */}</footer>
```

## ARIA Attributes

```typescript
// Icons
<button aria-label="Search">
  <SearchIcon aria-hidden="true" />
</button>

// Form fields
<div>
  <label id="email-label" htmlFor="email">Email</label>
  <input
    id="email"
    type="email"
    aria-labelledby="email-label"
    aria-describedby="email-help"
    aria-invalid={hasError}
    aria-required="true"
  />
  <span id="email-help">We'll never share your email</span>
  {hasError && <span role="alert">Invalid email</span>}
</div>

// Expandable content
<button aria-expanded={isOpen} aria-controls="panel-1">
  Toggle
</button>
<div id="panel-1" hidden={!isOpen}>
  Content
</div>

// Live regions
<div role="status" aria-live="polite" aria-atomic="true">
  {message}
</div>

// Modal dialogs
<div role="dialog" aria-modal="true" aria-labelledby="dialog-title">
  <h2 id="dialog-title">Dialog Title</h2>
</div>
```

## Keyboard Navigation

```typescript
function Modal({ isOpen, onClose }: ModalProps) {
  const closeRef = useRef<HTMLButtonElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      closeRef.current?.focus();

      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === "Escape") onClose();

        if (e.key === "Tab") {
          const focusable = modalRef.current?.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );
          if (!focusable?.length) return;

          const first = focusable[0] as HTMLElement;
          const last = focusable[focusable.length - 1] as HTMLElement;

          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault();
            last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault();
            first.focus();
          }
        }
      };

      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div ref={modalRef} role="dialog" aria-modal="true">
      <button ref={closeRef} onClick={onClose}>Close</button>
    </div>
  );
}

// Skip link
<a
  href="#main-content"
  className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4"
>
  Skip to main content
</a>
```

## Color and Contrast

```typescript
// WCAG AA compliant colors
const colors = {
  text: {
    primary: "text-gray-900 dark:text-gray-100", // 4.5:1+
    secondary: "text-gray-600 dark:text-gray-400", // 4.5:1+
  },
  // Don't rely on color alone
  status: {
    success: "bg-green-100 text-green-900 border-2 border-green-600",
    error: "bg-red-100 text-red-900 border-2 border-red-600",
  },
};

// Focus indicators
const focusStyles = "focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2";
```

## Accessible Components

```typescript
// Tabs
function Tabs({ tabs }: { tabs: Tab[] }) {
  const [activeTab, setActiveTab] = useState(tabs[0].id);

  return (
    <div>
      <div role="tablist" aria-label="Tabs">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            role="tab"
            aria-selected={activeTab === tab.id}
            aria-controls={`panel-${tab.id}`}
            id={`tab-${tab.id}`}
            tabIndex={activeTab === tab.id ? 0 : -1}
            onClick={() => setActiveTab(tab.id)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      {tabs.map((tab) => (
        <div
          key={tab.id}
          role="tabpanel"
          id={`panel-${tab.id}`}
          aria-labelledby={`tab-${tab.id}`}
          hidden={activeTab !== tab.id}
          tabIndex={0}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
}

// Loading button
<button disabled={loading} aria-busy={loading}>
  {loading && <span className="spinner" aria-hidden="true" />}
  <span>{loading ? "Loading..." : children}</span>
</button>

// Visually hidden text
<button>
  <TrashIcon aria-hidden="true" />
  <span className="sr-only">Delete item</span>
</button>
```

## Testing Accessibility

```typescript
import { render } from "@testing-library/react";
import { axe, toHaveNoViolations } from "jest-axe";

expect.extend(toHaveNoViolations);

test("Button is accessible", async () => {
  const { container } = render(<Button>Click me</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

## Critical Rules

### Always
- Use semantic HTML elements
- Provide text alternatives
- Ensure keyboard navigation
- Test with screen readers
- Meet WCAG 2.1 AA

### Never
- Skip alt text for images
- Use divs for interactive elements
- Rely on color alone
- Trap keyboard focus
- Ignore focus indicators


---

# API Integration

Type-safe API clients and data fetching patterns.

## Type-Safe Fetch Wrapper

```typescript
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

class ApiError extends Error {
  constructor(
    public status: number,
    public statusText: string,
    public data?: unknown
  ) {
    super(`API Error: ${status} ${statusText}`);
    this.name = "ApiError";
  }
}

class ApiClient {
  constructor(private baseUrl: string) {}

  private async request<T>(
    method: HttpMethod,
    path: string,
    options?: { body?: unknown; params?: Record<string, string> }
  ): Promise<T> {
    const url = new URL(path, this.baseUrl);
    if (options?.params) {
      Object.entries(options.params).forEach(([k, v]) =>
        url.searchParams.set(k, v)
      );
    }

    const response = await fetch(url.toString(), {
      method,
      headers: { "Content-Type": "application/json" },
      body: options?.body ? JSON.stringify(options.body) : undefined,
    });

    if (!response.ok) {
      const data = await response.json().catch(() => null);
      throw new ApiError(response.status, response.statusText, data);
    }

    return response.status === 204 ? (undefined as T) : response.json();
  }

  get<T>(path: string, params?: Record<string, string>) {
    return this.request<T>("GET", path, { params });
  }

  post<T>(path: string, body?: unknown) {
    return this.request<T>("POST", path, { body });
  }

  put<T>(path: string, body?: unknown) {
    return this.request<T>("PUT", path, { body });
  }

  delete<T>(path: string) {
    return this.request<T>("DELETE", path);
  }
}

export const api = new ApiClient(process.env.NEXT_PUBLIC_API_URL!);
```

## React Query Integration

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

// Query keys factory
export const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// Query hook
export function useUsers(filters?: { search?: string }) {
  return useQuery({
    queryKey: filters ? userKeys.list(JSON.stringify(filters)) : userKeys.lists(),
    queryFn: () => api.get<User[]>("/users", filters as any),
    staleTime: 5 * 60 * 1000,
  });
}

// Mutation with optimistic updates
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<User> }) =>
      api.put<User>(`/users/${id}`, data),
    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({ queryKey: userKeys.detail(id) });
      const previous = queryClient.getQueryData<User>(userKeys.detail(id));
      queryClient.setQueryData<User>(userKeys.detail(id), (old) =>
        old ? { ...old, ...data } : undefined
      );
      return { previous };
    },
    onError: (_, { id }, context) => {
      if (context?.previous) {
        queryClient.setQueryData(userKeys.detail(id), context.previous);
      }
    },
    onSettled: (_, __, { id }) => {
      queryClient.invalidateQueries({ queryKey: userKeys.detail(id) });
    },
  });
}
```

## tRPC (End-to-End Type Safety)

```typescript
// server/routers/user.ts
import { z } from "zod";
import { router, publicProcedure } from "../trpc";

export const userRouter = router({
  list: publicProcedure
    .input(z.object({ search: z.string().optional() }).optional())
    .query(async ({ input, ctx }) => {
      return ctx.db.user.findMany({
        where: input?.search ? { name: { contains: input.search } } : undefined,
      });
    }),

  create: publicProcedure
    .input(z.object({ name: z.string(), email: z.string().email() }))
    .mutation(async ({ input, ctx }) => {
      return ctx.db.user.create({ data: input });
    }),
});

// client usage - fully type-safe!
const { data: users } = trpc.user.list.useQuery({ search: "John" });
const createUser = trpc.user.create.useMutation();
createUser.mutate({ name: "Alice", email: "alice@example.com" });
```

## WebSocket Integration

```typescript
type MessageHandler<T> = (data: T) => void;

class TypedWebSocket {
  private ws: WebSocket | null = null;
  private handlers = new Map<string, Set<MessageHandler<any>>>();

  constructor(private url: string) {}

  connect() {
    this.ws = new WebSocket(this.url);
    this.ws.onmessage = (event) => {
      const { type, data } = JSON.parse(event.data);
      this.handlers.get(type)?.forEach((h) => h(data));
    };
  }

  on<T>(type: string, handler: MessageHandler<T>): () => void {
    if (!this.handlers.has(type)) this.handlers.set(type, new Set());
    this.handlers.get(type)!.add(handler);
    return () => this.handlers.get(type)?.delete(handler);
  }

  send<T>(type: string, data: T) {
    this.ws?.send(JSON.stringify({ type, data }));
  }

  disconnect() {
    this.ws?.close();
  }
}

// React hook
function useWebSocket<T>(url: string, type: string, handler: (data: T) => void) {
  const wsRef = useRef<TypedWebSocket>();

  useEffect(() => {
    const ws = new TypedWebSocket(url);
    ws.connect();
    wsRef.current = ws;
    const unsubscribe = ws.on(type, handler);
    return () => {
      unsubscribe();
      ws.disconnect();
    };
  }, [url, type, handler]);

  return wsRef.current;
}
```

## Error Handling

```typescript
// Result type pattern
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

async function safeApiCall<T>(fn: () => Promise<T>): Promise<Result<T>> {
  try {
    const data = await fn();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}

// Usage
const result = await safeApiCall(() => api.get<User>("/users/123"));
if (result.success) {
  console.log(result.data.name);
} else {
  console.error(result.error.message);
}
```

## Critical Rules

### Always
- Type all API requests/responses
- Handle errors explicitly
- Use React Query for server state
- Implement request cancellation
- Add loading/error states

### Never
- Use any for API responses
- Skip error handling
- Store API data in local state
- Forget network failure handling
- Make requests in useEffect (use React Query)


---

# TypeScript Core

Foundation for modern TypeScript development with strict type safety.

## TypeScript Stack

| Component | Default | Alternative |
|-----------|---------|-------------|
| Runtime | Node.js 20+ | Bun, Deno |
| Package Manager | pnpm | npm, yarn |
| Bundler | Vite | webpack, esbuild |
| Linter | ESLint | Biome |
| Formatter | Prettier | Biome |
| Test Runner | Vitest | Jest |

## Project Structure

```
my-app/
├── src/
│   ├── components/
│   ├── lib/
│   │   ├── types/
│   │   ├── utils/
│   │   └── hooks/
│   ├── app/              # Next.js App Router
│   └── index.ts
├── tests/
├── public/
├── tsconfig.json
├── package.json
└── vitest.config.ts
```

## TSConfig Best Practices

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,

    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

## Modern TypeScript Features

```typescript
// Type-safe object keys
const user = { name: "John", age: 30 } as const;
type UserKeys = keyof typeof user; // "name" | "age"

// Satisfies operator (TypeScript 4.9+)
const config = {
  host: "localhost",
  port: 3000,
  ssl: false
} satisfies Config; // Type-check without widening

// Template literal types
type HTTPMethod = "GET" | "POST";
type Endpoint = `/api/${string}`;
type Route = `${HTTPMethod} ${Endpoint}`;

// Const type parameters (TypeScript 5.0+)
function makeArray<const T>(arr: T[]) {
  return arr;
}
const arr = makeArray([1, 2, 3]); // Type: readonly [1, 2, 3]

// Using declarations (TypeScript 5.2+)
{
  using file = openFile("data.txt");
  // Automatically disposed at end of block
}
```

## Type Utilities

```typescript
// Pick and Omit
type User = { id: number; name: string; email: string; };
type UserPreview = Pick<User, "id" | "name">;
type PublicUser = Omit<User, "email">;

// Partial and Required
type PartialUser = Partial<User>; // All optional
type RequiredUser = Required<User>; // All required

// Record for mapped types
type UserRoles = Record<string, "admin" | "user" | "guest">;

// Awaited for async types
type ApiResponse = Awaited<ReturnType<typeof fetchUser>>;

// Branded types for type safety
type UserId = number & { __brand: "UserId" };
type PostId = number & { __brand: "PostId" };
```

## Strict Null Checking

```typescript
// Handle null/undefined properly
function getUser(id: string): User | null {
  const user = database.find(id);
  return user ?? null; // Nullish coalescing
}

const user = getUser("123");
if (user) {
  // Type narrowed to User
  console.log(user.name);
}

// Optional chaining
const email = user?.profile?.email;

// Non-null assertion (use sparingly)
const element = document.getElementById("app")!;
```

## Type Guards

```typescript
// Type predicates
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === "object" &&
    obj !== null &&
    "id" in obj &&
    "name" in obj
  );
}

// Discriminated unions
type Success = { status: "success"; data: string };
type Error = { status: "error"; message: string };
type Result = Success | Error;

function handleResult(result: Result) {
  if (result.status === "success") {
    console.log(result.data); // Type narrowed to Success
  } else {
    console.error(result.message); // Type narrowed to Error
  }
}
```

## Critical Rules

### Always
- Use strict mode in tsconfig
- Enable noUncheckedIndexedAccess
- Type all function parameters and returns
- Use const assertions for literal types
- Handle null/undefined explicitly

### Never
- Use any (use unknown instead)
- Use ! (non-null assertion) without justification
- Disable strict checks
- Ignore TypeScript errors with @ts-ignore
- Skip type annotations on public APIs


---

# Modern JavaScript (ESM)

ESM patterns and deciding between JavaScript and TypeScript.

## JS vs TS Decision Guide

| Scenario | Recommendation |
|----------|----------------|
| New project, team knows TS | TypeScript |
| Quick script/automation | JavaScript |
| Library with public API | TypeScript |
| Legacy codebase | Gradual migration |
| Prototyping | JavaScript |
| Large team | TypeScript |

### Use JavaScript for
- Quick scripts and utilities
- Prototyping
- Simple Node.js scripts

### Use TypeScript for
- Large applications
- Libraries with public APIs
- Complex business logic

## ESM Fundamentals

```json
// package.json
{
  "type": "module",
  "exports": {
    ".": {
      "import": "./src/index.js",
      "types": "./types/index.d.ts"
    }
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
```

### Import/Export

```javascript
// Named exports
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;

// Default export
export default class User {
  constructor(name) {
    this.name = name;
  }
}

// Re-exports
export { formatDate } from "./formatters.js";
export * from "./utils.js";

// Import patterns
import User from "./user.js";
import { add, PI } from "./math.js";
import * as math from "./math.js";

// Dynamic imports
const module = await import("./heavy-module.js");

// IMPORTANT: Include file extensions in ESM
import { helper } from "./utils.js"; // ✅
import { helper } from "./utils";    // ❌ Error
```

## JSDoc Type Hints

```javascript
/**
 * @typedef {Object} User
 * @property {string} id
 * @property {string} name
 * @property {"admin" | "user"} role
 */

/**
 * Get user by ID
 * @param {string} id
 * @returns {Promise<User>}
 */
export async function getUser(id) {
  return db.users.findById(id);
}

/**
 * Calculate total
 * @template T
 * @param {T[]} items
 * @param {(item: T) => number} getPrice
 * @returns {number}
 */
export function calculateTotal(items, getPrice) {
  return items.reduce((sum, item) => sum + getPrice(item), 0);
}

/**
 * @param {string | number} value
 * @returns {string}
 */
export function toString(value) {
  return String(value);
}
```

## Node.js ESM Specifics

```javascript
import { fileURLToPath } from "url";
import { dirname, join } from "path";

// __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read file relative to module
import fs from "fs/promises";
const config = await fs.readFile(join(__dirname, "config.json"), "utf-8");

// Top-level await (ESM only)
const data = await fetch("https://api.example.com").then((r) => r.json());

// Import meta
console.log(import.meta.url); // file:///path/to/file.js
```

## React Without TypeScript

```javascript
import PropTypes from "prop-types";

/**
 * @typedef {Object} ButtonProps
 * @property {React.ReactNode} children
 * @property {() => void} onClick
 * @property {"primary" | "secondary"} [variant]
 */

/**
 * @param {ButtonProps} props
 */
export function Button({ children, onClick, variant = "primary" }) {
  return (
    <button onClick={onClick} className={`btn btn-${variant}`}>
      {children}
    </button>
  );
}

Button.propTypes = {
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func.isRequired,
  variant: PropTypes.oneOf(["primary", "secondary"]),
};
```

## Migration to TypeScript

### Step 1: Add JSDoc types
```javascript
/**
 * @param {string} id
 * @returns {Promise<User>}
 */
export async function getUser(id) {
  return db.users.get(id);
}
```

### Step 2: Enable TS checking
```json
// tsconfig.json
{
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "noEmit": true
  },
  "include": ["src/**/*.js"]
}
```

### Step 3: Rename incrementally
```bash
mv src/utils.js src/utils.ts
mv src/user-service.js src/user-service.ts
```

### Step 4: Enable strict mode gradually
```json
{
  "compilerOptions": {
    "strict": false,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

## Tree-Shaking

```javascript
// ✅ Tree-shakeable (named exports)
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// ❌ Less tree-shakeable
export default {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
};
```

## Critical Rules

### Always
- Use ESM (import/export)
- Include .js extensions
- Set "type": "module"
- Document with JSDoc
- Consider TS for large projects

### Never
- Mix CommonJS and ESM
- Forget file extensions
- Use require() in ESM
- Skip documentation
- Over-complicate simple scripts


---

# Form Patterns

Type-safe, accessible forms with React Hook Form and Zod.

## Form Stack

| Component | Tool | Purpose |
|-----------|------|---------|
| Form Library | React Hook Form | Type-safe forms |
| Validation | Zod | Schema validation |
| Submission | Server Actions | Server-side handling |

## React Hook Form Basics

```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const loginSchema = z.object({
  email: z.string().email("Invalid email"),
  password: z.string().min(8, "Min 8 characters"),
  rememberMe: z.boolean().optional(),
});

type LoginFormData = z.infer<typeof loginSchema>;

export function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    await api.login(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="email" {...register("email")} aria-invalid={!!errors.email} />
        {errors.email && <span role="alert">{errors.email.message}</span>}
      </div>

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" type="password" {...register("password")} />
        {errors.password && <span role="alert">{errors.password.message}</span>}
      </div>

      <label>
        <input type="checkbox" {...register("rememberMe")} />
        Remember me
      </label>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading..." : "Login"}
      </button>
    </form>
  );
}
```

## Zod Schema Patterns

```typescript
import { z } from "zod";

// Basic types
const userSchema = z.object({
  name: z.string().min(1, "Required"),
  email: z.string().email(),
  age: z.number().int().min(18),
  website: z.string().url().optional(),
});

// Enums
const roleSchema = z.enum(["admin", "user", "guest"]);

// Discriminated unions
const notificationSchema = z.discriminatedUnion("type", [
  z.object({ type: z.literal("email"), email: z.string().email() }),
  z.object({ type: z.literal("sms"), phone: z.string() }),
]);

// Custom validation
const passwordSchema = z
  .string()
  .min(8)
  .regex(/[A-Z]/, "Must contain uppercase")
  .regex(/[0-9]/, "Must contain number");

// Refinements for cross-field validation
const signupSchema = z
  .object({
    password: z.string(),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

// Transform data
const dateSchema = z.string().transform((str) => new Date(str));
```

## Server Actions Integration

```typescript
// app/users/actions.ts
"use server";

import { z } from "zod";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  role: z.enum(["admin", "user"]),
});

export type FormState = {
  errors?: Record<string, string[]>;
  success?: boolean;
};

export async function createUser(
  prevState: FormState,
  formData: FormData
): Promise<FormState> {
  const result = createUserSchema.safeParse({
    name: formData.get("name"),
    email: formData.get("email"),
    role: formData.get("role"),
  });

  if (!result.success) {
    return { errors: result.error.flatten().fieldErrors };
  }

  try {
    await db.user.create({ data: result.data });
    revalidatePath("/users");
    redirect("/users");
  } catch {
    return { errors: { _form: ["Failed to create user"] } };
  }
}

// Client component
"use client";

import { useFormState, useFormStatus } from "react-dom";
import { createUser } from "./actions";

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Creating..." : "Create"}
    </button>
  );
}

export default function NewUserForm() {
  const [state, formAction] = useFormState(createUser, {});

  return (
    <form action={formAction}>
      <input name="name" required />
      {state.errors?.name && <span>{state.errors.name}</span>}

      <input name="email" type="email" required />
      {state.errors?.email && <span>{state.errors.email}</span>}

      <select name="role">
        <option value="user">User</option>
        <option value="admin">Admin</option>
      </select>

      <SubmitButton />
    </form>
  );
}
```

## File Uploads

```typescript
const fileSchema = z.object({
  file: z
    .instanceof(File)
    .refine((f) => f.size <= 5_000_000, "Max 5MB")
    .refine(
      (f) => ["image/jpeg", "image/png"].includes(f.type),
      "Only .jpg/.png"
    ),
});

function FileUploadForm() {
  const { register, handleSubmit } = useForm<{ file: File }>({
    resolver: zodResolver(fileSchema),
  });

  const onSubmit = async (data: { file: File }) => {
    const formData = new FormData();
    formData.append("file", data.file);
    await fetch("/api/upload", { method: "POST", body: formData });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input type="file" {...register("file")} accept="image/jpeg,image/png" />
      <button type="submit">Upload</button>
    </form>
  );
}
```

## Multi-Step Forms

```typescript
function useMultiStepForm<T>(steps: number) {
  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState<Partial<T>>({});

  return {
    currentStep,
    formData,
    next: (data: Partial<T>) => {
      setFormData((prev) => ({ ...prev, ...data }));
      setCurrentStep((s) => Math.min(s + 1, steps - 1));
    },
    prev: () => setCurrentStep((s) => Math.max(s - 1, 0)),
    isFirst: currentStep === 0,
    isLast: currentStep === steps - 1,
  };
}

// Usage
function WizardForm() {
  const { currentStep, formData, next, prev, isLast } = useMultiStepForm<CompleteData>(3);

  return (
    <div>
      {currentStep === 0 && <Step1 onNext={next} defaultValues={formData} />}
      {currentStep === 1 && <Step2 onNext={next} onPrev={prev} defaultValues={formData} />}
      {currentStep === 2 && <Step3 onSubmit={handleFinal} onPrev={prev} defaultValues={formData} />}
    </div>
  );
}
```

## Critical Rules

### Always
- Use Zod for schema validation
- Validate on both client and server
- Include proper ARIA attributes
- Handle submission states
- Use uncontrolled inputs by default

### Never
- Trust client-side validation only
- Skip error messages
- Forget disabled state during submission
- Ignore accessibility
- Use controlled inputs unnecessarily

